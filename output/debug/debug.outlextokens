[inlinecmt, // ====== struct declarations ====== //\n, 2]
[struct, struct, 3]
[id, POLYNOMIAL, 3]
[opencubr, {, 3]
[public, public, 4]
[func, func, 4]
[id, evaluate, 4]
[openpar, (, 4]
[id, x, 4]
[colon, :, 4]
[float, float, 4]
[closepar, ), 4]
[arrow, ->, 4]
[float, float, 4]
[semi, ;, 4]
[closecubr, }, 5]
[semi, ;, 5]
[struct, struct, 7]
[id, QUADRATIC, 7]
[inherits, inherits, 7]
[id, POLYNOMIAL, 7]
[opencubr, {, 7]
[private, private, 8]
[let, let, 8]
[id, a, 8]
[colon, :, 8]
[float, float, 8]
[semi, ;, 8]
[private, private, 9]
[let, let, 9]
[id, b, 9]
[colon, :, 9]
[float, float, 9]
[semi, ;, 9]
[private, private, 10]
[let, let, 10]
[id, c, 10]
[colon, :, 10]
[float, float, 10]
[semi, ;, 10]
[public, public, 11]
[func, func, 11]
[id, build, 11]
[openpar, (, 11]
[id, A, 11]
[colon, :, 11]
[float, float, 11]
[comma, ,, 11]
[id, B, 11]
[colon, :, 11]
[float, float, 11]
[comma, ,, 11]
[id, C, 11]
[colon, :, 11]
[float, float, 11]
[closepar, ), 11]
[arrow, ->, 11]
[id, QUADRATIC, 11]
[semi, ;, 11]
[public, public, 12]
[func, func, 12]
[id, evaluate, 12]
[openpar, (, 12]
[id, x, 12]
[colon, :, 12]
[float, float, 12]
[closepar, ), 12]
[arrow, ->, 12]
[float, float, 12]
[semi, ;, 12]
[closecubr, }, 13]
[semi, ;, 13]
[impl, impl, 15]
[id, QUADRATIC, 15]
[opencubr, {, 15]
[func, func, 16]
[id, evaluate, 16]
[openpar, (, 16]
[id, x, 16]
[colon, :, 16]
[float, float, 16]
[closepar, ), 16]
[arrow, ->, 16]
[float, float, 16]
[opencubr, {, 17]
[let, let, 18]
[id, result, 18]
[colon, :, 18]
[float, float, 18]
[semi, ;, 18]
[inlinecmt, //Using Horner's method\n, 19]
[id, result, 20]
[assign, =, 20]
[id, a, 20]
[semi, ;, 20]
[id, result, 21]
[assign, =, 21]
[id, result, 21]
[mult, *, 21]
[id, x, 21]
[plus, +, 21]
[id, b, 21]
[semi, ;, 21]
[id, result, 22]
[assign, =, 22]
[id, result, 22]
[mult, *, 22]
[id, x, 22]
[plus, +, 22]
[id, c, 22]
[semi, ;, 22]
[return, return, 23]
[openpar, (, 23]
[id, result, 23]
[closepar, ), 23]
[semi, ;, 23]
[closecubr, }, 24]
[func, func, 25]
[id, build, 25]
[openpar, (, 25]
[id, A, 25]
[colon, :, 25]
[float, float, 25]
[comma, ,, 25]
[id, B, 25]
[colon, :, 25]
[float, float, 25]
[comma, ,, 25]
[id, C, 25]
[colon, :, 25]
[float, float, 25]
[closepar, ), 25]
[arrow, ->, 25]
[id, QUADRATIC, 25]
[opencubr, {, 26]
[let, let, 27]
[id, new_function, 27]
[colon, :, 27]
[id, QUADRATIC, 27]
[semi, ;, 27]
[id, new_function, 28]
[dot, ., 28]
[id, a, 28]
[assign, =, 28]
[id, A, 28]
[semi, ;, 28]
[id, new_function, 29]
[dot, ., 29]
[id, b, 29]
[assign, =, 29]
[id, B, 29]
[semi, ;, 29]
[id, new_function, 30]
[dot, ., 30]
[id, c, 30]
[assign, =, 30]
[id, C, 30]
[semi, ;, 30]
[return, return, 31]
[openpar, (, 31]
[id, new_function, 31]
[closepar, ), 31]
[semi, ;, 31]
[closecubr, }, 32]
[closecubr, }, 33]
[blockcmt, /*\nfunc debug() -> void\n{\n\ta.b[c][2].d = 1;\n\ta.b.c = 2;\n}\n*/, 35]
[inlinecmt, //let v : integer[2][3];\n, 42]
[inlinecmt, //let v : integer[2][3];\n, 43]
[blockcmt, /*\nstruct LINEAR {\n\tprivate let a: float;\n\tprivate let b: float[];\n\tpublic  func build(A: float, B: float) -> LINEAR;\n\tpublic  func evaluate(x: float) -> float;\n};\n*/, 44]
[blockcmt, /*\nstruct LINEAR {\n\tprivate let a: float;\n\tprivate let b: float;\n\tpublic  func build(A: float, B: float) -> LINEAR;\n\tpublic  func evaluate(x: float) -> float;\n};\n*/, 52]
[$, $, 60]
